{"id": "afd19d65-ba01-494e-8458-705f18f2ef8f", "code": "# initial_program.py\n\nimport random\n\n# EVOLVE-BLOCK-START\ndef run_search():\n    n = 47\n    S = []\n    \n    # Add points based on a quadratic residue sequence. This helps avoid collinearity.\n    for i in range(n):\n        S.append((i, (i*i) % n))\n\n    def is_collinear(p1, p2, p3):\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)\n\n    # Instead of removing points upon collinearity, which can be inefficient, \n    # let's construct the set directly using the quadratic residue sequence.\n    # If a point causes collinearity, we'll skip it.\n\n    def is_collinear(p1, p2, p3):\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)\n    \n    new_S = []\n    for i in range(n):\n        point = (i, (i*i) % n)\n        \n        collinear = False\n        for p1_idx in range(len(new_S)):\n            for p2_idx in range(p1_idx + 1, len(new_S)):\n                if is_collinear(new_S[p1_idx], new_S[p2_idx], point):\n                    collinear = True\n                    break\n            if collinear:\n                break\n        \n        if not collinear:\n            new_S.append(point)\n    \n    S = new_S\n\n    return S\n# EVOLVE-BLOCK-END ", "language": "python", "parent_id": "c9eaacce-e586-42c7-b2fb-cb9e00d14f65", "generation": 3, "timestamp": 1748145529.341218, "iteration_found": 34, "metrics": {"point_count": 47.0, "overall_score": 47.0, "runtime": 0.02164149284362793, "valid_solution": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 16 lines with 27 lines", "parent_metrics": {"point_count": 47.0, "overall_score": 47.0, "runtime": 0.04398036003112793, "valid_solution": 1.0}}}